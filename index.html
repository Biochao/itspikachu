<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Who's That Pokémon?</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="sunburst"></div>
    
    <div class="content">
        <div class="header">
            <h1 class="title">WHO'S THAT POKÉMON?!</h1>
            <p class="subtitle">Classic Anime Segment Browser</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="seasonSelect">Select Season:</label>
                <select id="seasonSelect">
                    <option value="">Any Season</option>
                </select>
                <label for="pokemonSelect">Select Pokémon:</label>
                <select id="pokemonSelect">
                    <option value="">Any Pokémon</option>
                </select>
                <label for="imageSelect">Select Episode:</label>
                <select id="imageSelect">
                    <option value="">Choose an Episode</option>
                </select>
            </div>
        </div>

        <div class="display-container">
            <div class="image-display">
                <div class="episode-info">
                    <div class="pokemon-name" id="pokemonName">???</div>
                    <div class="episode-details" id="episodeDetails"></div>
                    <div class="hint">Click the image to reveal!</div>
                </div>
                <div class="pokemon-image" id="pokemonImage">
                    <div class="placeholder">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Load images.json (generated by generate_images_manifest.py) which contains
        // an array of relative image paths (e.g. "images/Some File.jpg").
        // This avoids keeping a large hardcoded list in the HTML and prevents
        // filename mismatches.
    let imageData = [];

    const seasonSelect = document.getElementById('seasonSelect');
    const pokemonSelect = document.getElementById('pokemonSelect');
    const imageSelect = document.getElementById('imageSelect');
    const pokemonImage = document.getElementById('pokemonImage');
    const pokemonName = document.getElementById('pokemonName');
    const episodeDetails = document.getElementById('episodeDetails');

    // seasons manifest: { seasonName: [file, ...], ... }
    let seasonsManifest = {};

    function formatSeasonLabel(season) {
        // Try to extract number from names like 'season1', 'season01', 's1', 'S01'
        const m = season.match(/(season|s)[\-_ ]*(0*)(\d+)/i);
        if (m) return 'Season ' + parseInt(m[3], 10);
        const m2 = season.match(/^(\d+)$/);
        if (m2) return 'Season ' + parseInt(m2[1], 10);
        // fallback: title-case the folder name
        return season.replace(/[_\-]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function setStatus(msg, isError = false) {
        // manifestStatus element removed; log to console instead
        if (isError) console.warn(msg);
        else console.log(msg);
    }

    // Load manifest with cache-busting query param so you can regenerate images.json and click reload
    function loadManifest() {
        setStatus('Loading...');
        const url = `images.json?cb=${Date.now()}`;
        fetch(url)
            .then(res => {
                if (!res.ok) throw new Error(`images.json not found (${res.status})`);
                return res.json();
            })
            .then(obj => {
                // obj is a mapping season -> [file, ...]
                seasonsManifest = obj || {};
                // populate seasonSelect
                populateSeasonSelect();
                // by default, if there is a 'root' or first season, select it
                const firstSeason = Object.keys(seasonsManifest)[0] || '';
                if (firstSeason) {
                    seasonSelect.value = firstSeason;
                    loadSeason(firstSeason);
                }
                const total = Object.values(seasonsManifest).reduce((s, a) => s + a.length, 0);
                setStatus(`Loaded ${total} images in ${Object.keys(seasonsManifest).length} seasons`);
            })
            .catch(err => {
                console.error(err);
                setStatus(`Error: ${err.message}`, true);
                // show in select as fallback
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No images found (run generate_images_manifest.py)';
                imageSelect.innerHTML = '';
                imageSelect.appendChild(option);
            });
    }

    // Load manifest on startup
    loadManifest();

        // populate season select
        function populateSeasonSelect() {
            seasonSelect.innerHTML = '<option value="">All Seasons</option>';
            Object.keys(seasonsManifest).forEach(season => {
                const option = document.createElement('option');
                option.value = season;
                option.textContent = formatSeasonLabel(season);
                seasonSelect.appendChild(option);
            });
        }

        function loadSeason(season) {
            const files = seasonsManifest[season] || [];
            imageData = files.map(parseFilename);
            // repopulate episodes dropdown
            imageSelect.innerHTML = '<option value="">Choose an Episode</option>';
            imageData.forEach((img, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${img.season}x${img.episode.padStart(2, '0')} - ${img.episodeName}`;
                imageSelect.appendChild(option);
            });
                populatePokemonSelect();
                if (pokemonSelect) pokemonSelect.value = '';
            if (imageData.length) {
                loadRandomImage();
            }
        }

        function populatePokemonSelect() {
            // Collect unique pokemon names from imageData and sort
            const names = Array.from(new Set(imageData.map(i => (i.pokemon||'').trim()).filter(Boolean)));
            names.sort((a,b) => a.localeCompare(b));
            pokemonSelect.innerHTML = '<option value="">All Pokémon</option>';
            names.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                pokemonSelect.appendChild(opt);
            });
        }

        function parseFilename(filename) {
            // Extract filename without path and extension
            const parts = filename.split('/').pop().replace('.jpg', '').split('_');
            
            // Parse episode info (everything before first underscore of pokemon name)
            const episodePart = parts[0];
            const episodeMatch = episodePart.match(/(.+?) - (\d+)x(\d+) - (.+)/);
            
            // compute revealPath by replacing the last occurrence of `_1` before the extension with `_2`
            const revealPath = filename.replace(/_1(\.[^./]+)$/i, '_2$1');

            const info = {
                show: episodeMatch ? episodeMatch[1] : '',
                season: episodeMatch ? episodeMatch[2] : '',
                episode: episodeMatch ? episodeMatch[3] : '',
                episodeName: episodeMatch ? episodeMatch[4] : '',
                pokemon: parts[1] || '',
                imageType: parts[2] || '',
                silhouettePath: filename,
                revealPath: revealPath
            };
            
            return info;
        }

        
        let currentImage = null;
        let showingReveal = false;

        // Load random image on page load
        function loadRandomImage() {
            const randomIdx = Math.floor(Math.random() * imageData.length);
            loadImage(randomIdx);
            imageSelect.value = randomIdx;
        }

        function loadImage(idx) {
            currentImage = imageData[idx];
            showingReveal = false;
            updateDisplay();
        }

        function updateDisplay() {
            const imgPath = showingReveal ? currentImage.revealPath : currentImage.silhouettePath;
            // Try several variants of the filename to handle spaces, percent-encoding,
            // and Unicode normalization differences (NFC vs NFD). This helps when
            // filesystem filenames use a different Unicode composition than the
            // hardcoded strings in `imageFiles`.
            tryImageVariants(imgPath, function(imgElement) {
                if (imgElement) {
                        imgElement.alt = 'Pokemon';
                        imgElement.onerror = function() { handleImageError(this); };
                        // Clear and append the loaded image
                        pokemonImage.innerHTML = '';
                        pokemonImage.appendChild(imgElement);

                        // set container width to the image's natural width, clamped to viewport
                        // find the display-container
                        const displayContainer = document.querySelector('.display-container');
                        if (displayContainer && imgElement.naturalWidth) {
                            // account for container padding (40px each side)
                            const maxWidth = Math.max(document.documentElement.clientWidth - 40, 200);
                            const desired = Math.min(imgElement.naturalWidth, maxWidth);
                            displayContainer.style.width = desired + 'px';
                        }
                    } else {
                    pokemonImage.innerHTML = '<div class="placeholder">Image not found<br><small>Please ensure images are in the images/ folder</small></div>';
                }
            });
            
            if (showingReveal) {
                pokemonName.textContent = currentImage.pokemon;
                document.querySelector('.hint').textContent = 'Click to see silhouette again';
            } else {
                pokemonName.textContent = '???';
                document.querySelector('.hint').textContent = 'Click the image to reveal!';
            }
            
            episodeDetails.textContent = `${currentImage.show} - Season ${currentImage.season}, Episode ${currentImage.episode}: ${currentImage.episodeName}`;
        }

        function toggleImage() {
            if (currentImage) {
                showingReveal = !showingReveal;
                updateDisplay();
            }
        }

        // Event listeners
        seasonSelect.addEventListener('change', (e) => {
            const season = e.target.value;
            if (season) loadSeason(season);
            else {
                // if All Seasons selected, merge all files
                const allFiles = [].concat(...Object.values(seasonsManifest));
                imageData = allFiles.map(parseFilename);
                imageSelect.innerHTML = '<option value="">Choose an Episode</option>';
                imageData.forEach((img, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = `${img.season}x${img.episode.padStart(2, '0')} - ${img.episodeName}`;
                    imageSelect.appendChild(option);
                });
                // populate pokemon select from merged list
                populatePokemonSelect();
                if (imageData.length) loadRandomImage();
            }
        });

        pokemonSelect.addEventListener('change', (e) => {
            const name = e.target.value;
            if (!name) {
                // Reset to current season's full episode list
                const season = seasonSelect.value;
                if (season) loadSeason(season);
                else {
                    const allFiles = [].concat(...Object.values(seasonsManifest));
                    imageData = allFiles.map(parseFilename);
                    imageSelect.innerHTML = '<option value="">Choose an Episode</option>';
                    imageData.forEach((img, idx) => {
                        const option = document.createElement('option');
                        option.value = idx;
                        option.textContent = `${img.season}x${img.episode.padStart(2, '0')} - ${img.episodeName}`;
                        imageSelect.appendChild(option);
                    });
                    // ensure pokemonSelect shows names for the current (all) selection
                    populatePokemonSelect();
                }
                return;
            }

            // Filter imageData by pokemon name and repopulate episode dropdown
            const filtered = imageData.map((img, idx) => ({img, idx})).filter(x => x.img.pokemon && x.img.pokemon.toLowerCase() === name.toLowerCase());
            imageSelect.innerHTML = '<option value="">Choose an Episode</option>';
            filtered.forEach(x => {
                const option = document.createElement('option');
                option.value = x.idx;
                option.textContent = `${x.img.season}x${x.img.episode.padStart(2, '0')} - ${x.img.episodeName}`;
                imageSelect.appendChild(option);
            });
            if (filtered.length) {
                loadImage(parseInt(filtered[0].idx));
            }
        });

        imageSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                loadImage(parseInt(e.target.value));
            }
        });

        pokemonImage.addEventListener('click', toggleImage);

        // Handle image loading errors
        window.handleImageError = function(img) {
            img.parentElement.innerHTML = '<div class="placeholder">Image not found<br><small>Please ensure images are in the /images/ folder</small></div>';
        };

        // Try different filename variants (raw, encoded, NFC/NFD) and call cb(img) on first success
        function tryImageVariants(path, cb) {
            const seen = new Set();
            const variants = [];

            function pushVariant(p) {
                if (!p) return;
                if (!seen.has(p)) {
                    seen.add(p);
                    variants.push(p);
                }
            }

            pushVariant(path);
            pushVariant(encodeURI(path));

            if (typeof path.normalize === 'function') {
                try {
                    pushVariant(path.normalize('NFC'));
                    pushVariant(path.normalize('NFD'));
                    pushVariant(encodeURI(path.normalize('NFC')));
                    pushVariant(encodeURI(path.normalize('NFD')));
                } catch (e) {
                    // ignore normalization errors
                }
            }

            let i = 0;
            function tryNext() {
                if (i >= variants.length) return cb(null);
                const p = variants[i++];
                const img = new Image();
                img.onload = function() { cb(img); };
                img.onerror = function() { tryNext(); };
                img.src = p;
            }

            tryNext();
        }

    // Note: images are loaded and dropdown populated after images.json is fetched
    </script>
</body>
</html>